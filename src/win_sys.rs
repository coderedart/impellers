#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused)]
#![allow(rustdoc::invalid_codeblock_attributes)]
#![allow(rustdoc::invalid_rust_codeblocks)]
#![allow(rustdoc::broken_intra_doc_links)]
/* automatically generated by rust-bindgen 0.71.1 */

pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2Y: u32 = 0;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 42;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const IMPELLER_VERSION_VARIANT: u32 = 1;
pub const IMPELLER_VERSION_MAJOR: u32 = 1;
pub const IMPELLER_VERSION_MINOR: u32 = 4;
pub const IMPELLER_VERSION_PATCH: u32 = 0;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce1"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    ["Offset of field: max_align_t::__clang_max_align_nonce2"]
        [::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    ["Offset of field: __fsid_t::__val"][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerContext_ {
    _unused: [u8; 0],
}
#[doc = "An Impeller graphics context. Contexts are platform and client-rendering-API\nspecific.\n\nContexts are thread-safe objects that are expensive to create. Most\napplications will only ever create a single context during their lifetimes.\nOnce setup, Impeller is ready to render frames as performantly as possible.\n\nDuring setup, context create the underlying graphics pipelines, allocators,\nworker threads, etc...\n\nThe general guidance is to create as few contexts as possible (typically\njust one) and share them as much as possible.\n"]
pub type ImpellerContext = *mut ImpellerContext_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerDisplayList_ {
    _unused: [u8; 0],
}
#[doc = "Display lists represent encoded rendering intent. These objects are\nimmutable, reusable, thread-safe, and context-agnostic.\n\nWhile it is perfectly fine to create new display lists per frame, there may\nbe opportunities for optimization when display lists are reused multiple\ntimes.\n"]
pub type ImpellerDisplayList = *mut ImpellerDisplayList_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerDisplayListBuilder_ {
    _unused: [u8; 0],
}
#[doc = "Display list builders allow for the incremental creation of display lists.\n\nDisplay list builders are context-agnostic.\n"]
pub type ImpellerDisplayListBuilder = *mut ImpellerDisplayListBuilder_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerPaint_ {
    _unused: [u8; 0],
}
#[doc = "Paints control the behavior of draw calls encoded in a display list.\n\nLike display lists, paints are context-agnostic.\n"]
pub type ImpellerPaint = *mut ImpellerPaint_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerColorFilter_ {
    _unused: [u8; 0],
}
#[doc = "Color filters are functions that take two colors and mix them to produce a\nsingle color. This color is then merged with the destination during\nblending.\n"]
pub type ImpellerColorFilter = *mut ImpellerColorFilter_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerColorSource_ {
    _unused: [u8; 0],
}
#[doc = "Color sources are functions that generate colors for each texture element\ncovered by a draw call. The colors for each element can be generated using a\nmathematical function (to produce gradients for example) or sampled from a\ntexture.\n"]
pub type ImpellerColorSource = *mut ImpellerColorSource_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerImageFilter_ {
    _unused: [u8; 0],
}
#[doc = "Image filters are functions that are applied regions of a texture to produce\na single color. Contrast this with color filters that operate independently\non a per-pixel basis. The generated color is then merged with the\ndestination during blending.\n"]
pub type ImpellerImageFilter = *mut ImpellerImageFilter_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerMaskFilter_ {
    _unused: [u8; 0],
}
#[doc = "Mask filters are functions that are applied over a shape after it has been\ndrawn but before it has been blended into the final image.\n"]
pub type ImpellerMaskFilter = *mut ImpellerMaskFilter_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerTypographyContext_ {
    _unused: [u8; 0],
}
#[doc = "Typography contexts allow for the layout and rendering of text.\n\nThese are typically expensive to create and applications will only ever need\nto create a single one of these during their lifetimes.\n\nUnlike graphics context, typograhy contexts are not thread-safe. These must\nbe created, used, and collected on a single thread.\n"]
pub type ImpellerTypographyContext = *mut ImpellerTypographyContext_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerParagraph_ {
    _unused: [u8; 0],
}
#[doc = "An immutable, fully laid out paragraph.\n"]
pub type ImpellerParagraph = *mut ImpellerParagraph_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerParagraphBuilder_ {
    _unused: [u8; 0],
}
#[doc = "Paragraph builders allow for the creation of fully laid out paragraphs\n(which themselves are immutable).\n\nTo build a paragraph, users push/pop paragraph styles onto a stack then add\nUTF-8 encoded text. The properties on the top of paragraph style stack when\nthe text is added are used to layout and shape that subset of the paragraph.\n\n@see      `ImpellerParagraphStyle`\n"]
pub type ImpellerParagraphBuilder = *mut ImpellerParagraphBuilder_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerParagraphStyle_ {
    _unused: [u8; 0],
}
#[doc = "Specified when building a paragraph, paragraph styles are managed in a stack\nwith specify text properties to apply to text that is added to the paragraph\nbuilder.\n"]
pub type ImpellerParagraphStyle = *mut ImpellerParagraphStyle_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerLineMetrics_ {
    _unused: [u8; 0],
}
#[doc = "Describes the metrics of lines in a fully laid out paragraph.\n\nRegardless of how the string of text is specified to the paragraph builder,\noffsets into buffers that are returned by line metrics are always assumed to\nbe into buffers of UTF-16 code units.\n"]
pub type ImpellerLineMetrics = *mut ImpellerLineMetrics_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerGlyphInfo_ {
    _unused: [u8; 0],
}
#[doc = "Describes the metrics of glyphs in a paragraph line.\n"]
pub type ImpellerGlyphInfo = *mut ImpellerGlyphInfo_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerPath_ {
    _unused: [u8; 0],
}
#[doc = "Represents a two-dimensional path that is immutable and graphics context\nagnostic.\n\nPaths in Impeller consist of linear, cubic Bézier curve, and quadratic\nBézier curve segments. All other shapes are approximations using these\nbuilding blocks.\n\nPaths are created using path builder that allow for the configuration of the\npath segments, how they are filled, and/or stroked.\n"]
pub type ImpellerPath = *mut ImpellerPath_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerPathBuilder_ {
    _unused: [u8; 0],
}
#[doc = "Path builders allow for the incremental building up of paths.\n"]
pub type ImpellerPathBuilder = *mut ImpellerPathBuilder_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerSurface_ {
    _unused: [u8; 0],
}
#[doc = "A surface represents a render target for Impeller to direct the rendering\nintent specified the form of display lists to.\n\nRender targets are how Impeller API users perform Window System Integration\n(WSI). Users wrap swapchain images as surfaces and draw display lists onto\nthese surfaces to present content.\n\nCreating surfaces is typically platform and client-rendering-API specific.\n"]
pub type ImpellerSurface = *mut ImpellerSurface_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerTexture_ {
    _unused: [u8; 0],
}
#[doc = "A reference to a texture whose data is resident on the GPU. These can be\nreferenced in draw calls and paints.\n\nCreating textures is extremely expensive. Creating a single one can\ntypically comfortably blow the frame budget of an application. Textures\nshould be created on background threads.\n\n@warning    While textures themselves are thread safe, some context types\n(like OpenGL) may need extra configuration to be able to operate\nfrom multiple threads.\n"]
pub type ImpellerTexture = *mut ImpellerTexture_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerVulkanSwapchain_ {
    _unused: [u8; 0],
}
#[doc = "The primary form of WSI when using a Vulkan context, these swapchains use\nthe `VK_KHR_surface` Vulkan extension.\n\nCreating a swapchain is extremely expensive. One must be created at\napplication startup and re-used throughout the application lifecycle.\n\nSwapchains are resilient to the underlying surfaces being resized. The\nswapchain images will be re-created as necessary on-demand.\n"]
pub type ImpellerVulkanSwapchain = *mut ImpellerVulkanSwapchain_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerFragmentProgram_ {
    _unused: [u8; 0],
}
#[doc = "A fragment shader is a small program that is authored in GLSL and compiled\nusing `impellerc` that runs on each pixel covered by a polygon and allows\nthe user to configure how it is shaded.\n\n@see https://docs.flutter.dev/ui/design/graphics/fragment-shaders\n"]
pub type ImpellerFragmentProgram = *mut ImpellerFragmentProgram_;
#[doc = "A callback invoked by Impeller that passes a user supplied baton back to the\nuser. Impeller does not interpret the baton in any way. The way the baton is\nspecified and the thread on which the callback is invoked depends on how the\nuser supplies the callback to Impeller.\n"]
pub type ImpellerCallback =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = "A callback used by Impeller to allow the user to resolve function pointers.\nA user supplied baton that is uninterpreted by Impeller is passed back to\nthe user in the callback. How the baton is specified to Impeller and the\nthread on which the callback is invoked depends on how the callback is\nspecified to Impeller.\n"]
pub type ImpellerProcAddressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        proc_name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = "A callback used by Impeller to allow the user to resolve Vulkan function\npointers. A user supplied baton that is uninterpreted by Impeller is passed\nback to the user in the callback.\n"]
pub type ImpellerVulkanProcAddressCallback = ::std::option::Option<
    unsafe extern "C" fn(
        vulkan_instance: *mut ::std::os::raw::c_void,
        vulkan_proc_name: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FillType {
    NonZero = 0,
    Odd = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ClipOperation {
    Difference = 0,
    Intersect = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BlendMode {
    Clear = 0,
    Source = 1,
    Destination = 2,
    SourceOver = 3,
    DestinationOver = 4,
    SourceIn = 5,
    DestinationIn = 6,
    SourceOut = 7,
    DestinationOut = 8,
    SourceATop = 9,
    DestinationATop = 10,
    Xor = 11,
    Plus = 12,
    Modulate = 13,
    Screen = 14,
    Overlay = 15,
    Darken = 16,
    Lighten = 17,
    ColorDodge = 18,
    ColorBurn = 19,
    HardLight = 20,
    SoftLight = 21,
    Difference = 22,
    Exclusion = 23,
    Multiply = 24,
    Hue = 25,
    Saturation = 26,
    Color = 27,
    Luminosity = 28,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum DrawStyle {
    Fill = 0,
    Stroke = 1,
    StrokeAndFill = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum StrokeCap {
    Butt = 0,
    Round = 1,
    Square = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum StrokeJoin {
    Miter = 0,
    Round = 1,
    Bevel = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum PixelFormat {
    RGBA8888 = 0,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TextureSampling {
    NearestNeighbor = 0,
    Linear = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TileMode {
    Clamp = 0,
    Repeat = 1,
    Mirror = 2,
    Decal = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum BlurStyle {
    Normal = 0,
    Solid = 1,
    Outer = 2,
    Inner = 3,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum ColorSpace {
    SRGB = 0,
    ExtendedSRGB = 1,
    DisplayP3 = 2,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FontWeight {
    Thin = 0,
    ExtraLight = 1,
    Light = 2,
    Regular = 3,
    Medium = 4,
    SemiBold = 5,
    Bold = 6,
    ExtraBold = 7,
    Black = 8,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum FontStyle {
    Normal = 0,
    Italic = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TextAlignment {
    Left = 0,
    Right = 1,
    Center = 2,
    Justify = 3,
    Start = 4,
    End = 5,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TextDirection {
    RTL = 0,
    LTR = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TextDecorationType {
    None = 0,
    Underline = 1,
    Overline = 2,
    LineThrough = 4,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum TextDecorationStyle {
    Solid = 0,
    Double = 1,
    Dotted = 2,
    Dashed = 3,
    Wavy = 4,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ImpellerRect {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerRect"][::std::mem::size_of::<ImpellerRect>() - 16usize];
    ["Alignment of ImpellerRect"][::std::mem::align_of::<ImpellerRect>() - 4usize];
    ["Offset of field: ImpellerRect::x"][::std::mem::offset_of!(ImpellerRect, x) - 0usize];
    ["Offset of field: ImpellerRect::y"][::std::mem::offset_of!(ImpellerRect, y) - 4usize];
    ["Offset of field: ImpellerRect::width"][::std::mem::offset_of!(ImpellerRect, width) - 8usize];
    ["Offset of field: ImpellerRect::height"]
        [::std::mem::offset_of!(ImpellerRect, height) - 12usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ImpellerPoint {
    pub x: f32,
    pub y: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerPoint"][::std::mem::size_of::<ImpellerPoint>() - 8usize];
    ["Alignment of ImpellerPoint"][::std::mem::align_of::<ImpellerPoint>() - 4usize];
    ["Offset of field: ImpellerPoint::x"][::std::mem::offset_of!(ImpellerPoint, x) - 0usize];
    ["Offset of field: ImpellerPoint::y"][::std::mem::offset_of!(ImpellerPoint, y) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ImpellerSize {
    pub width: f32,
    pub height: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerSize"][::std::mem::size_of::<ImpellerSize>() - 8usize];
    ["Alignment of ImpellerSize"][::std::mem::align_of::<ImpellerSize>() - 4usize];
    ["Offset of field: ImpellerSize::width"][::std::mem::offset_of!(ImpellerSize, width) - 0usize];
    ["Offset of field: ImpellerSize::height"]
        [::std::mem::offset_of!(ImpellerSize, height) - 4usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ImpellerISize {
    pub width: i64,
    pub height: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerISize"][::std::mem::size_of::<ImpellerISize>() - 16usize];
    ["Alignment of ImpellerISize"][::std::mem::align_of::<ImpellerISize>() - 8usize];
    ["Offset of field: ImpellerISize::width"]
        [::std::mem::offset_of!(ImpellerISize, width) - 0usize];
    ["Offset of field: ImpellerISize::height"]
        [::std::mem::offset_of!(ImpellerISize, height) - 8usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ImpellerRange {
    pub start: u64,
    pub end: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerRange"][::std::mem::size_of::<ImpellerRange>() - 16usize];
    ["Alignment of ImpellerRange"][::std::mem::align_of::<ImpellerRange>() - 8usize];
    ["Offset of field: ImpellerRange::start"]
        [::std::mem::offset_of!(ImpellerRange, start) - 0usize];
    ["Offset of field: ImpellerRange::end"][::std::mem::offset_of!(ImpellerRange, end) - 8usize];
};
#[doc = "A 4x4 transformation matrix using column-major storage.\n\n```cpp\n| m[0] m[4] m[8]  m[12] |\n| m[1] m[5] m[9]  m[13] |\n| m[2] m[6] m[10] m[14] |\n| m[3] m[7] m[11] m[15] |\n```\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ImpellerMatrix {
    pub m: [f32; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerMatrix"][::std::mem::size_of::<ImpellerMatrix>() - 64usize];
    ["Alignment of ImpellerMatrix"][::std::mem::align_of::<ImpellerMatrix>() - 4usize];
    ["Offset of field: ImpellerMatrix::m"][::std::mem::offset_of!(ImpellerMatrix, m) - 0usize];
};
#[doc = "A 4x5 matrix using row-major storage used for transforming color values.\n\nTo transform color values, a 5x5 matrix is constructed with the 5th row\nbeing identity. Then the following transformation is performed:\n\n```cpp\n| R' |   | m[0]  m[1]  m[2]  m[3]  m[4]  |   | R |\n| G' |   | m[5]  m[6]  m[7]  m[8]  m[9]  |   | G |\n| B' | = | m[10] m[11] m[12] m[13] m[14] | * | B |\n| A' |   | m[15] m[16] m[17] m[18] m[19] |   | A |\n| 1  |   | 0     0     0     0     1     |   | 1 |\n```\n\nThe translation column (m[4], m[9], m[14], m[19]) must be specified in\nnon-normalized 8-bit unsigned integer space (0 to 255). Values outside this\nrange will produce undefined results.\n\nThe identity transformation is thus:\n\n```cpp\n1, 0, 0, 0, 0,\n0, 1, 0, 0, 0,\n0, 0, 1, 0, 0,\n0, 0, 0, 1, 0,\n```\n\nSome examples:\n\nTo invert all colors:\n\n```cpp\n-1,  0,  0, 0, 255,\n0, -1,  0, 0, 255,\n0,  0, -1, 0, 255,\n0,  0,  0, 1,   0,\n```\n\nTo apply a sepia filter:\n\n```cpp\n0.393, 0.769, 0.189, 0, 0,\n0.349, 0.686, 0.168, 0, 0,\n0.272, 0.534, 0.131, 0, 0,\n0,     0,     0,     1, 0,\n```\n\nTo apply a grayscale conversion filter:\n\n```cpp\n0.2126, 0.7152, 0.0722, 0, 0,\n0.2126, 0.7152, 0.0722, 0, 0,\n0.2126, 0.7152, 0.0722, 0, 0,\n0,      0,      0,      1, 0,\n```\n\n@see      ImpellerColorFilter\n"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ImpellerColorMatrix {
    pub m: [f32; 20usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerColorMatrix"][::std::mem::size_of::<ImpellerColorMatrix>() - 80usize];
    ["Alignment of ImpellerColorMatrix"][::std::mem::align_of::<ImpellerColorMatrix>() - 4usize];
    ["Offset of field: ImpellerColorMatrix::m"]
        [::std::mem::offset_of!(ImpellerColorMatrix, m) - 0usize];
};
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ImpellerRoundingRadii {
    pub top_left: ImpellerPoint,
    pub bottom_left: ImpellerPoint,
    pub top_right: ImpellerPoint,
    pub bottom_right: ImpellerPoint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerRoundingRadii"][::std::mem::size_of::<ImpellerRoundingRadii>() - 32usize];
    ["Alignment of ImpellerRoundingRadii"]
        [::std::mem::align_of::<ImpellerRoundingRadii>() - 4usize];
    ["Offset of field: ImpellerRoundingRadii::top_left"]
        [::std::mem::offset_of!(ImpellerRoundingRadii, top_left) - 0usize];
    ["Offset of field: ImpellerRoundingRadii::bottom_left"]
        [::std::mem::offset_of!(ImpellerRoundingRadii, bottom_left) - 8usize];
    ["Offset of field: ImpellerRoundingRadii::top_right"]
        [::std::mem::offset_of!(ImpellerRoundingRadii, top_right) - 16usize];
    ["Offset of field: ImpellerRoundingRadii::bottom_right"]
        [::std::mem::offset_of!(ImpellerRoundingRadii, bottom_right) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerColor {
    pub red: f32,
    pub green: f32,
    pub blue: f32,
    pub alpha: f32,
    pub color_space: ColorSpace,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerColor"][::std::mem::size_of::<ImpellerColor>() - 20usize];
    ["Alignment of ImpellerColor"][::std::mem::align_of::<ImpellerColor>() - 4usize];
    ["Offset of field: ImpellerColor::red"][::std::mem::offset_of!(ImpellerColor, red) - 0usize];
    ["Offset of field: ImpellerColor::green"]
        [::std::mem::offset_of!(ImpellerColor, green) - 4usize];
    ["Offset of field: ImpellerColor::blue"][::std::mem::offset_of!(ImpellerColor, blue) - 8usize];
    ["Offset of field: ImpellerColor::alpha"]
        [::std::mem::offset_of!(ImpellerColor, alpha) - 12usize];
    ["Offset of field: ImpellerColor::color_space"]
        [::std::mem::offset_of!(ImpellerColor, color_space) - 16usize];
};
impl Default for ImpellerColor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerTextureDescriptor {
    pub pixel_format: PixelFormat,
    pub size: ImpellerISize,
    pub mip_count: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerTextureDescriptor"]
        [::std::mem::size_of::<ImpellerTextureDescriptor>() - 32usize];
    ["Alignment of ImpellerTextureDescriptor"]
        [::std::mem::align_of::<ImpellerTextureDescriptor>() - 8usize];
    ["Offset of field: ImpellerTextureDescriptor::pixel_format"]
        [::std::mem::offset_of!(ImpellerTextureDescriptor, pixel_format) - 0usize];
    ["Offset of field: ImpellerTextureDescriptor::size"]
        [::std::mem::offset_of!(ImpellerTextureDescriptor, size) - 8usize];
    ["Offset of field: ImpellerTextureDescriptor::mip_count"]
        [::std::mem::offset_of!(ImpellerTextureDescriptor, mip_count) - 24usize];
};
impl Default for ImpellerTextureDescriptor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerMapping {
    pub data: *const u8,
    pub length: u64,
    pub on_release: ImpellerCallback,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerMapping"][::std::mem::size_of::<ImpellerMapping>() - 24usize];
    ["Alignment of ImpellerMapping"][::std::mem::align_of::<ImpellerMapping>() - 8usize];
    ["Offset of field: ImpellerMapping::data"]
        [::std::mem::offset_of!(ImpellerMapping, data) - 0usize];
    ["Offset of field: ImpellerMapping::length"]
        [::std::mem::offset_of!(ImpellerMapping, length) - 8usize];
    ["Offset of field: ImpellerMapping::on_release"]
        [::std::mem::offset_of!(ImpellerMapping, on_release) - 16usize];
};
impl Default for ImpellerMapping {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerContextVulkanSettings {
    pub user_data: *mut ::std::os::raw::c_void,
    pub proc_address_callback: ImpellerVulkanProcAddressCallback,
    pub enable_vulkan_validation: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerContextVulkanSettings"]
        [::std::mem::size_of::<ImpellerContextVulkanSettings>() - 24usize];
    ["Alignment of ImpellerContextVulkanSettings"]
        [::std::mem::align_of::<ImpellerContextVulkanSettings>() - 8usize];
    ["Offset of field: ImpellerContextVulkanSettings::user_data"]
        [::std::mem::offset_of!(ImpellerContextVulkanSettings, user_data) - 0usize];
    ["Offset of field: ImpellerContextVulkanSettings::proc_address_callback"]
        [::std::mem::offset_of!(ImpellerContextVulkanSettings, proc_address_callback) - 8usize];
    ["Offset of field: ImpellerContextVulkanSettings::enable_vulkan_validation"]
        [::std::mem::offset_of!(ImpellerContextVulkanSettings, enable_vulkan_validation) - 16usize];
};
impl Default for ImpellerContextVulkanSettings {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerContextVulkanInfo {
    pub vk_instance: *mut ::std::os::raw::c_void,
    pub vk_physical_device: *mut ::std::os::raw::c_void,
    pub vk_logical_device: *mut ::std::os::raw::c_void,
    pub graphics_queue_family_index: u32,
    pub graphics_queue_index: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerContextVulkanInfo"]
        [::std::mem::size_of::<ImpellerContextVulkanInfo>() - 32usize];
    ["Alignment of ImpellerContextVulkanInfo"]
        [::std::mem::align_of::<ImpellerContextVulkanInfo>() - 8usize];
    ["Offset of field: ImpellerContextVulkanInfo::vk_instance"]
        [::std::mem::offset_of!(ImpellerContextVulkanInfo, vk_instance) - 0usize];
    ["Offset of field: ImpellerContextVulkanInfo::vk_physical_device"]
        [::std::mem::offset_of!(ImpellerContextVulkanInfo, vk_physical_device) - 8usize];
    ["Offset of field: ImpellerContextVulkanInfo::vk_logical_device"]
        [::std::mem::offset_of!(ImpellerContextVulkanInfo, vk_logical_device) - 16usize];
    ["Offset of field: ImpellerContextVulkanInfo::graphics_queue_family_index"]
        [::std::mem::offset_of!(ImpellerContextVulkanInfo, graphics_queue_family_index) - 24usize];
    ["Offset of field: ImpellerContextVulkanInfo::graphics_queue_index"]
        [::std::mem::offset_of!(ImpellerContextVulkanInfo, graphics_queue_index) - 28usize];
};
impl Default for ImpellerContextVulkanInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ImpellerTextDecoration {
    #[doc = "A mask of `ImpellerTextDecorationType`s to enable.\n"]
    pub types: ::std::os::raw::c_int,
    #[doc = "The decoration color.\n"]
    pub color: ImpellerColor,
    #[doc = "The decoration style.\n"]
    pub style: TextDecorationStyle,
    pub thickness_multiplier: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of ImpellerTextDecoration"][::std::mem::size_of::<ImpellerTextDecoration>() - 32usize];
    ["Alignment of ImpellerTextDecoration"]
        [::std::mem::align_of::<ImpellerTextDecoration>() - 4usize];
    ["Offset of field: ImpellerTextDecoration::types"]
        [::std::mem::offset_of!(ImpellerTextDecoration, types) - 0usize];
    ["Offset of field: ImpellerTextDecoration::color"]
        [::std::mem::offset_of!(ImpellerTextDecoration, color) - 4usize];
    ["Offset of field: ImpellerTextDecoration::style"]
        [::std::mem::offset_of!(ImpellerTextDecoration, style) - 24usize];
    ["Offset of field: ImpellerTextDecoration::thickness_multiplier"]
        [::std::mem::offset_of!(ImpellerTextDecoration, thickness_multiplier) - 28usize];
};
impl Default for ImpellerTextDecoration {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = "@brief      Get the version of Impeller standalone API. This is the API that\nwill be accepted for validity checks when provided to the\ncontext creation methods.\n\nThe current version of the API  is denoted by the\n`IMPELLER_VERSION` macro. This version must be passed to APIs\nthat create top-level objects like graphics contexts.\nConstruction of the context may fail if the API version expected\nby the caller is not supported by the library.\n\nSince there are no API stability guarantees today, passing a\nversion that is different to the one returned by\n`ImpellerGetVersion` will always fail.\n\n@see        `ImpellerContextCreateOpenGLESNew`\n\n@return     The version of the standalone API.\n"]
    pub fn ImpellerGetVersion() -> u32;
    #[doc = "@brief      Create an OpenGL(ES) Impeller context.\n\n@warning    Unlike other context types, the OpenGL ES context can only be\ncreated, used, and collected on the calling thread. This\nrestriction may be lifted in the future once reactor workers are\nexposed in the API. No other context types have threading\nrestrictions. Till reactor workers can be used, using the\ncontext on a background thread will cause a stall of OpenGL\noperations.\n\n@param[in]  version      The version of the Impeller\nstandalone API. See `ImpellerGetVersion`. If the\nspecified here is not compatible with the version\nof the library, context creation will fail and NULL\ncontext returned from this call.\n@param[in]  gl_proc_address_callback\nThe gl proc address callback. For instance,\n`eglGetProcAddress`.\n@param[in]  gl_proc_address_callback_user_data\nThe gl proc address callback user data baton. This\npointer is not interpreted by Impeller and will be\nreturned as user data in the proc address callback.\nuser data.\n\n@return     The context or NULL if one cannot be created.\n"]
    pub fn ImpellerContextCreateOpenGLESNew(
        version: u32,
        gl_proc_address_callback: ImpellerProcAddressCallback,
        gl_proc_address_callback_user_data: *mut ::std::os::raw::c_void,
    ) -> ImpellerContext;
    #[doc = "@brief      Create a Metal context using the system default Metal device.\n\n@param[in]  version  The version specified in the IMPELLER_VERSION macro.\n\n@return     The Metal context or NULL if one cannot be created.\n"]
    pub fn ImpellerContextCreateMetalNew(version: u32) -> ImpellerContext;
    #[doc = "@brief      Create a Vulkan context using the provided Vulkan Settings.\n\n@param[in]  version   The version specified in the IMPELLER_VERSION macro.\n@param[in]  settings  The Vulkan settings.\n\n@return     The Vulkan context or NULL if one cannot be created.\n"]
    pub fn ImpellerContextCreateVulkanNew(
        version: u32,
        settings: *const ImpellerContextVulkanSettings,
    ) -> ImpellerContext;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  context  The context.\n"]
    pub fn ImpellerContextRetain(context: ImpellerContext);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  context  The context.\n"]
    pub fn ImpellerContextRelease(context: ImpellerContext);
    #[doc = "@brief      Get internal Vulkan handles managed by the given Vulkan context.\nOwnership of the handles is still maintained by Impeller. This\naccessor is just available so embedders can create resources\nusing the same device and instance as Impeller for interop.\n\n@warning    If the context is not a Vulkan context, False is returned with\nthe [out] argument unaffected.\n\n@param[in]  context          The context\n@param[out]  out_vulkan_info  The out vulkan information\n\n@return     If the Vulkan info could be fetched from the context.\n"]
    pub fn ImpellerContextGetVulkanInfo(
        context: ImpellerContext,
        out_vulkan_info: *mut ImpellerContextVulkanInfo,
    ) -> bool;
    #[doc = "@brief      Create a new Vulkan swapchain using a VkSurfaceKHR instance.\nOwnership of the surface is transferred over to Impeller. The\nVulkan instance the surface is created from must the same as the\ncontext provided.\n\n@param[in]  context             The context. Must be a Vulkan context whose\ninstance is the same used to create the\nsurface passed into the next argument.\n@param      vulkan_surface_khr  The vulkan surface.\n\n@return     The vulkan swapchain.\n"]
    pub fn ImpellerVulkanSwapchainCreateNew(
        context: ImpellerContext,
        vulkan_surface_khr: *mut ::std::os::raw::c_void,
    ) -> ImpellerVulkanSwapchain;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  swapchain  The swapchain.\n"]
    pub fn ImpellerVulkanSwapchainRetain(swapchain: ImpellerVulkanSwapchain);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  swapchain  The swapchain.\n"]
    pub fn ImpellerVulkanSwapchainRelease(swapchain: ImpellerVulkanSwapchain);
    #[doc = "@brief      A potentially blocking operation, acquires the next surface to\nrender to. Since this may block, surface acquisition must be\ndelayed for as long as possible to avoid an idle wait on the\nCPU.\n\n@param[in]  swapchain  The swapchain.\n\n@return     The surface if one could be obtained, NULL otherwise.\n"]
    pub fn ImpellerVulkanSwapchainAcquireNextSurfaceNew(
        swapchain: ImpellerVulkanSwapchain,
    ) -> ImpellerSurface;
    #[doc = "@brief      Create a new surface by wrapping an existing framebuffer object.\nThe framebuffer must be complete as determined by\n`glCheckFramebufferStatus`. The framebuffer is still owned by\nthe caller and it must be collected once the surface is\ncollected.\n\n@param[in]  context  The context.\n@param[in]  fbo      The framebuffer object handle.\n@param[in]  format   The format of the framebuffer.\n@param[in]  size     The size of the framebuffer is texels.\n\n@return     The surface if once can be created, NULL otherwise.\n"]
    pub fn ImpellerSurfaceCreateWrappedFBONew(
        context: ImpellerContext,
        fbo: u64,
        format: PixelFormat,
        size: *const ImpellerISize,
    ) -> ImpellerSurface;
    #[doc = "@brief      Create a surface by wrapping a Metal drawable. This is useful\nduring WSI when the drawable is the backing store of the Metal\nlayer being drawn to.\n\nThe Metal layer must be using the same device managed by the\nunderlying context.\n\n@param[in]  context         The context. The Metal device managed by this\ncontext must be the same used to create the\ndrawable that is being wrapped.\n@param      metal_drawable  The drawable to wrap as a surface.\n\n@return     The surface if one could be wrapped, NULL otherwise.\n"]
    pub fn ImpellerSurfaceCreateWrappedMetalDrawableNew(
        context: ImpellerContext,
        metal_drawable: *mut ::std::os::raw::c_void,
    ) -> ImpellerSurface;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  surface  The surface.\n"]
    pub fn ImpellerSurfaceRetain(surface: ImpellerSurface);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  surface  The surface.\n"]
    pub fn ImpellerSurfaceRelease(surface: ImpellerSurface);
    #[doc = "@brief      Draw a display list onto the surface. The same display list can\nbe drawn multiple times to different surfaces.\n\n@warning    In the OpenGL backend, Impeller will not make an effort to\npreserve the OpenGL state that is current in the context.\nEmbedders that perform additional OpenGL operations in the\ncontext should expect the reset state after control transitions\nback to them. Key state to watch out for would be the viewports,\nstencil rects, test toggles, resource (texture, framebuffer,\nbuffer) bindings, etc...\n\n@param[in]  surface       The surface to draw the display list to.\n@param[in]  display_list  The display list to draw onto the surface.\n\n@return     If the display list could be drawn onto the surface.\n"]
    pub fn ImpellerSurfaceDrawDisplayList(
        surface: ImpellerSurface,
        display_list: ImpellerDisplayList,
    ) -> bool;
    #[doc = "@brief      Present the surface to the underlying window system.\n\n@param[in]  surface  The surface to present.\n\n@return     True if the surface could be presented.\n"]
    pub fn ImpellerSurfacePresent(surface: ImpellerSurface) -> bool;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  path  The path.\n"]
    pub fn ImpellerPathRetain(path: ImpellerPath);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  path  The path.\n"]
    pub fn ImpellerPathRelease(path: ImpellerPath);
    #[doc = "@brief      Get the bounds of the path.\n\nThe bounds are conservative. That is, they may be larger than\nthe actual shape of the path and could include the control\npoints and isolated calls to move the cursor.\n\n@param[in]  path        The path\n@param[out] out_bounds  The conservative bounds of the path.\n"]
    pub fn ImpellerPathGetBounds(path: ImpellerPath, out_bounds: *mut ImpellerRect);
    #[doc = "@brief      Create a new path builder. Paths themselves are immutable.\nA builder builds these immutable paths.\n\n@return     The path builder.\n"]
    pub fn ImpellerPathBuilderNew() -> ImpellerPathBuilder;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  builder  The builder.\n"]
    pub fn ImpellerPathBuilderRetain(builder: ImpellerPathBuilder);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  builder  The builder.\n"]
    pub fn ImpellerPathBuilderRelease(builder: ImpellerPathBuilder);
    #[doc = "@brief      Move the cursor to the specified location.\n\n@param[in]  builder   The builder.\n@param[in]  location  The location.\n"]
    pub fn ImpellerPathBuilderMoveTo(builder: ImpellerPathBuilder, location: *const ImpellerPoint);
    #[doc = "@brief      Add a line segment from the current cursor location to the given\nlocation. The cursor location is updated to be at the endpoint.\n\n@param[in]  builder   The builder.\n@param[in]  location  The location.\n"]
    pub fn ImpellerPathBuilderLineTo(builder: ImpellerPathBuilder, location: *const ImpellerPoint);
    #[doc = "@brief      Add a quadratic curve from whose start point is the cursor to\nthe specified end point using the a single control point.\n\nThe new location of the cursor after this call is the end point.\n\n@param[in]  builder        The builder.\n@param[in]  control_point  The control point.\n@param[in]  end_point      The end point.\n"]
    pub fn ImpellerPathBuilderQuadraticCurveTo(
        builder: ImpellerPathBuilder,
        control_point: *const ImpellerPoint,
        end_point: *const ImpellerPoint,
    );
    #[doc = "@brief      Add a cubic curve whose start point is current cursor location\nto the specified end point using the two specified control\npoints.\n\nThe new location of the cursor after this call is the end point\nsupplied.\n\n@param[in]  builder          The builder\n@param[in]  control_point_1  The control point 1\n@param[in]  control_point_2  The control point 2\n@param[in]  end_point        The end point\n"]
    pub fn ImpellerPathBuilderCubicCurveTo(
        builder: ImpellerPathBuilder,
        control_point_1: *const ImpellerPoint,
        control_point_2: *const ImpellerPoint,
        end_point: *const ImpellerPoint,
    );
    #[doc = "@brief      Adds a rectangle to the path.\n\n@param[in]  builder  The builder.\n@param[in]  rect     The rectangle.\n"]
    pub fn ImpellerPathBuilderAddRect(builder: ImpellerPathBuilder, rect: *const ImpellerRect);
    #[doc = "@brief      Add an arc to the path.\n\n@param[in]  builder              The builder.\n@param[in]  oval_bounds          The oval bounds.\n@param[in]  start_angle_degrees  The start angle in degrees.\n@param[in]  end_angle_degrees    The end angle in degrees.\n"]
    pub fn ImpellerPathBuilderAddArc(
        builder: ImpellerPathBuilder,
        oval_bounds: *const ImpellerRect,
        start_angle_degrees: f32,
        end_angle_degrees: f32,
    );
    #[doc = "@brief      Add an oval to the path.\n\n@param[in]  builder      The builder.\n@param[in]  oval_bounds  The oval bounds.\n"]
    pub fn ImpellerPathBuilderAddOval(
        builder: ImpellerPathBuilder,
        oval_bounds: *const ImpellerRect,
    );
    #[doc = "@brief      Add a rounded rect with potentially non-uniform radii to the\npath.\n\n@param[in]  builder         The builder.\n@param[in]  rect            The rectangle.\n@param[in]  rounding_radii  The rounding radii.\n"]
    pub fn ImpellerPathBuilderAddRoundedRect(
        builder: ImpellerPathBuilder,
        rect: *const ImpellerRect,
        rounding_radii: *const ImpellerRoundingRadii,
    );
    #[doc = "@brief      Close the path.\n\n@param[in]  builder  The builder.\n"]
    pub fn ImpellerPathBuilderClose(builder: ImpellerPathBuilder);
    #[doc = "@brief      Create a new path by copying the existing built-up path. The\nexisting path can continue being added to.\n\n@param[in]  builder  The builder.\n@param[in]  fill     The fill.\n\n@return     The impeller path.\n"]
    pub fn ImpellerPathBuilderCopyPathNew(
        builder: ImpellerPathBuilder,
        fill: FillType,
    ) -> ImpellerPath;
    #[doc = "@brief      Create a new path using the existing built-up path. The existing\npath builder now contains an empty path.\n\n@param[in]  builder  The builder.\n@param[in]  fill     The fill.\n\n@return     The impeller path.\n"]
    pub fn ImpellerPathBuilderTakePathNew(
        builder: ImpellerPathBuilder,
        fill: FillType,
    ) -> ImpellerPath;
    #[doc = "@brief      Create a new paint with default values.\n\n@return     The impeller paint.\n"]
    pub fn ImpellerPaintNew() -> ImpellerPaint;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  paint  The paint.\n"]
    pub fn ImpellerPaintRetain(paint: ImpellerPaint);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  paint  The paint.\n"]
    pub fn ImpellerPaintRelease(paint: ImpellerPaint);
    #[doc = "@brief      Set the paint color.\n\n@param[in]  paint  The paint.\n@param[in]  color  The color.\n"]
    pub fn ImpellerPaintSetColor(paint: ImpellerPaint, color: *const ImpellerColor);
    #[doc = "@brief      Set the paint blend mode. The blend mode controls how the new\npaints contents are mixed with the values already drawn using\nprevious draw calls.\n\n@param[in]  paint  The paint.\n@param[in]  mode   The mode.\n"]
    pub fn ImpellerPaintSetBlendMode(paint: ImpellerPaint, mode: BlendMode);
    #[doc = "@brief      Set the paint draw style. The style controls if the closed\nshapes are filled and/or stroked.\n\n@param[in]  paint  The paint.\n@param[in]  style  The style.\n"]
    pub fn ImpellerPaintSetDrawStyle(paint: ImpellerPaint, style: DrawStyle);
    #[doc = "@brief      Sets how strokes rendered using this paint are capped.\n\n@param[in]  paint  The paint.\n@param[in]  cap    The stroke cap style.\n"]
    pub fn ImpellerPaintSetStrokeCap(paint: ImpellerPaint, cap: StrokeCap);
    #[doc = "@brief      Sets how strokes rendered using this paint are joined.\n\n@param[in]  paint  The paint.\n@param[in]  join   The join.\n"]
    pub fn ImpellerPaintSetStrokeJoin(paint: ImpellerPaint, join: StrokeJoin);
    #[doc = "@brief      Set the width of the strokes rendered using this paint.\n\n@param[in]  paint  The paint.\n@param[in]  width  The width.\n"]
    pub fn ImpellerPaintSetStrokeWidth(paint: ImpellerPaint, width: f32);
    #[doc = "@brief      Set the miter limit of the strokes rendered using this paint.\n\n@param[in]  paint  The paint.\n@param[in]  miter  The miter limit.\n"]
    pub fn ImpellerPaintSetStrokeMiter(paint: ImpellerPaint, miter: f32);
    #[doc = "@brief      Set the color filter of the paint.\n\nColor filters are functions that take two colors and mix them to\nproduce a single color. This color is then usually merged with\nthe destination during blending.\n\n@param[in]  paint         The paint.\n@param[in]  color_filter  The color filter.\n"]
    pub fn ImpellerPaintSetColorFilter(paint: ImpellerPaint, color_filter: ImpellerColorFilter);
    #[doc = "@brief      Set the color source of the paint.\n\nColor sources are functions that generate colors for each\ntexture element covered by a draw call.\n\n@param[in]  paint         The paint.\n@param[in]  color_source  The color source.\n"]
    pub fn ImpellerPaintSetColorSource(paint: ImpellerPaint, color_source: ImpellerColorSource);
    #[doc = "@brief      Set the image filter of a paint.\n\nImage filters are functions that are applied to regions of a\ntexture to produce a single color.\n\n@param[in]  paint         The paint.\n@param[in]  image_filter  The image filter.\n"]
    pub fn ImpellerPaintSetImageFilter(paint: ImpellerPaint, image_filter: ImpellerImageFilter);
    #[doc = "@brief      Set the mask filter of a paint.\n\n@param[in]  paint        The paint.\n@param[in]  mask_filter  The mask filter.\n"]
    pub fn ImpellerPaintSetMaskFilter(paint: ImpellerPaint, mask_filter: ImpellerMaskFilter);
    #[doc = "@brief      Create a texture with decompressed bytes.\n\nImpeller will do its best to perform the transfer of this data\nto GPU memory with a minimal number of copies. Towards this\nend, it may need to send this data to a different thread for\npreparation and transfer. To facilitate this transfer, it is\nrecommended that the content mapping have a release callback\nattach to it. When there is a release callback, Impeller assumes\nthat collection of the data can be deferred till texture upload\nis done and can happen on a background thread. When there is no\nrelease callback, Impeller may try to perform an eager copy of\nthe data if it needs to perform data preparation and transfer on\na background thread.\n\nWhether an extra data copy actually occurs will always depend on\nthe rendering backend in use. But it is best practice to provide\na release callback and be resilient to the data being released\nin a deferred manner on a background thread.\n\n@warning    Do **not** supply compressed image data directly (PNG, JPEG,\netc...). This function only works with tightly packed\ndecompressed data.\n\n@param[in]  context                        The context.\n@param[in]  descriptor                     The texture descriptor.\n@param[in]  contents                       The contents.\n@param[in]  contents_on_release_user_data  The baton passes to the contents\nrelease callback if one exists.\n\n@return     The texture if one can be created using the provided data, NULL\notherwise.\n"]
    pub fn ImpellerTextureCreateWithContentsNew(
        context: ImpellerContext,
        descriptor: *const ImpellerTextureDescriptor,
        contents: *const ImpellerMapping,
        contents_on_release_user_data: *mut ::std::os::raw::c_void,
    ) -> ImpellerTexture;
    #[doc = "@brief      Create a texture with an externally created OpenGL texture\nhandle.\n\nOwnership of the handle is transferred over to Impeller after a\nsuccessful call to this method. Impeller is responsible for\ncalling glDeleteTextures on this handle. Do **not** collect this\nhandle yourself as this will lead to a double-free.\n\nThe handle must be created in the same context as the one used\nby Impeller. If a different context is used, that context must\nbe in the same sharegroup as Impellers OpenGL context and all\nsynchronization of texture contents must already be complete.\n\nIf the context is not an OpenGL context, this call will always\nfail.\n\n@param[in]  context     The context\n@param[in]  descriptor  The descriptor\n@param[in]  handle      The handle\n\n@return     The texture if one could be created by adopting the supplied\ntexture handle, NULL otherwise.\n"]
    pub fn ImpellerTextureCreateWithOpenGLTextureHandleNew(
        context: ImpellerContext,
        descriptor: *const ImpellerTextureDescriptor,
        handle: u64,
    ) -> ImpellerTexture;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  texture  The texture.\n"]
    pub fn ImpellerTextureRetain(texture: ImpellerTexture);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  texture  The texture.\n"]
    pub fn ImpellerTextureRelease(texture: ImpellerTexture);
    #[doc = "@brief      Get the OpenGL handle associated with this texture. If this is\nnot an OpenGL texture, this method will always return 0.\n\nOpenGL handles are lazily created, this method will return\nGL_NONE is no OpenGL handle is available. To ensure that this\ncall eagerly creates an OpenGL texture, call this on a thread\nwhere Impeller knows there is an OpenGL context available.\n\n@param[in]  texture  The texture.\n\n@return     The OpenGL handle if one is available, GL_NONE otherwise.\n"]
    pub fn ImpellerTextureGetOpenGLHandle(texture: ImpellerTexture) -> u64;
    #[doc = "@brief      Create a new fragment program using data obtained by compiling a\nGLSL shader with `impellerc`.\n\n@warning    The data provided must be compiled by `impellerc`. Providing raw\nGLSL strings will lead to a `nullptr` return. Impeller does not\ncompile shaders at runtime.\n\n@param[in]  data                    The data compiled by `impellerc`.\n@param      data_release_user_data  A baton passed back to the caller on the\ninvocation of the mappings release\ncallback. This call can happen on any\nthread.\n\n@return     The fragment program if one can be created, nullptr otherwise.\n"]
    pub fn ImpellerFragmentProgramNew(
        data: *const ImpellerMapping,
        data_release_user_data: *mut ::std::os::raw::c_void,
    ) -> ImpellerFragmentProgram;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  fragment_program  The fragment program.\n"]
    pub fn ImpellerFragmentProgramRetain(fragment_program: ImpellerFragmentProgram);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  fragment_program  The fragment program.\n"]
    pub fn ImpellerFragmentProgramRelease(fragment_program: ImpellerFragmentProgram);
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  color_source  The color source.\n"]
    pub fn ImpellerColorSourceRetain(color_source: ImpellerColorSource);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  color_source  The color source.\n"]
    pub fn ImpellerColorSourceRelease(color_source: ImpellerColorSource);
    #[doc = "@brief      Create a color source that forms a linear gradient.\n\n@param[in]  start_point     The start point.\n@param[in]  end_point       The end point.\n@param[in]  stop_count      The stop count.\n@param[in]  colors          The colors.\n@param[in]  stops           The stops.\n@param[in]  tile_mode       The tile mode.\n@param[in]  transformation  The transformation.\n\n@return     The color source.\n"]
    pub fn ImpellerColorSourceCreateLinearGradientNew(
        start_point: *const ImpellerPoint,
        end_point: *const ImpellerPoint,
        stop_count: u32,
        colors: *const ImpellerColor,
        stops: *const f32,
        tile_mode: TileMode,
        transformation: *const ImpellerMatrix,
    ) -> ImpellerColorSource;
    #[doc = "@brief      Create a color source that forms a radial gradient.\n\n@param[in]  center          The center.\n@param[in]  radius          The radius.\n@param[in]  stop_count      The stop count.\n@param[in]  colors          The colors.\n@param[in]  stops           The stops.\n@param[in]  tile_mode       The tile mode.\n@param[in]  transformation  The transformation.\n\n@return     The color source.\n"]
    pub fn ImpellerColorSourceCreateRadialGradientNew(
        center: *const ImpellerPoint,
        radius: f32,
        stop_count: u32,
        colors: *const ImpellerColor,
        stops: *const f32,
        tile_mode: TileMode,
        transformation: *const ImpellerMatrix,
    ) -> ImpellerColorSource;
    #[doc = "@brief      Create a color source that forms a conical gradient.\n\n@param[in]  start_center    The start center.\n@param[in]  start_radius    The start radius.\n@param[in]  end_center      The end center.\n@param[in]  end_radius      The end radius.\n@param[in]  stop_count      The stop count.\n@param[in]  colors          The colors.\n@param[in]  stops           The stops.\n@param[in]  tile_mode       The tile mode.\n@param[in]  transformation  The transformation.\n\n@return     The color source.\n"]
    pub fn ImpellerColorSourceCreateConicalGradientNew(
        start_center: *const ImpellerPoint,
        start_radius: f32,
        end_center: *const ImpellerPoint,
        end_radius: f32,
        stop_count: u32,
        colors: *const ImpellerColor,
        stops: *const f32,
        tile_mode: TileMode,
        transformation: *const ImpellerMatrix,
    ) -> ImpellerColorSource;
    #[doc = "@brief      Create a color source that forms a sweep gradient.\n\n@param[in]  center          The center.\n@param[in]  start           The start.\n@param[in]  end             The end.\n@param[in]  stop_count      The stop count.\n@param[in]  colors          The colors.\n@param[in]  stops           The stops.\n@param[in]  tile_mode       The tile mode.\n@param[in]  transformation  The transformation.\n\n@return     The color source.\n"]
    pub fn ImpellerColorSourceCreateSweepGradientNew(
        center: *const ImpellerPoint,
        start: f32,
        end: f32,
        stop_count: u32,
        colors: *const ImpellerColor,
        stops: *const f32,
        tile_mode: TileMode,
        transformation: *const ImpellerMatrix,
    ) -> ImpellerColorSource;
    #[doc = "@brief      Create a color source that samples from an image.\n\n@param[in]  image                 The image.\n@param[in]  horizontal_tile_mode  The horizontal tile mode.\n@param[in]  vertical_tile_mode    The vertical tile mode.\n@param[in]  sampling              The sampling.\n@param[in]  transformation        The transformation.\n\n@return     The color source.\n"]
    pub fn ImpellerColorSourceCreateImageNew(
        image: ImpellerTexture,
        horizontal_tile_mode: TileMode,
        vertical_tile_mode: TileMode,
        sampling: TextureSampling,
        transformation: *const ImpellerMatrix,
    ) -> ImpellerColorSource;
    #[doc = "@brief      Create a color source whose pixels are shaded by a fragment\nprogram.\n\n@see        https://docs.flutter.dev/ui/design/graphics/fragment-shaders\n\n@param[in]  context            The context.\n@param[in]  fragment_program   The fragment program.\n@param      samplers           The samplers.\n@param[in]  samplers_count     The samplers count.\n@param[in]  data               The data (copied).\n@param[in]  data_bytes_length  The data bytes length.\n\n@return     The color source.\n"]
    pub fn ImpellerColorSourceCreateFragmentProgramNew(
        context: ImpellerContext,
        fragment_program: ImpellerFragmentProgram,
        samplers: *mut ImpellerTexture,
        samplers_count: usize,
        data: *const u8,
        data_bytes_length: usize,
    ) -> ImpellerColorSource;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  color_filter  The color filter.\n"]
    pub fn ImpellerColorFilterRetain(color_filter: ImpellerColorFilter);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  color_filter  The color filter.\n"]
    pub fn ImpellerColorFilterRelease(color_filter: ImpellerColorFilter);
    #[doc = "@brief      Create a color filter that performs blending of pixel values\nindependently.\n\n@param[in]  color       The color.\n@param[in]  blend_mode  The blend mode.\n\n@return     The color filter.\n"]
    pub fn ImpellerColorFilterCreateBlendNew(
        color: *const ImpellerColor,
        blend_mode: BlendMode,
    ) -> ImpellerColorFilter;
    #[doc = "@brief      Create a color filter that transforms pixel color values\nindependently.\n\n@param[in]  color_matrix  The color matrix.\n\n@return     The color filter.\n"]
    pub fn ImpellerColorFilterCreateColorMatrixNew(
        color_matrix: *const ImpellerColorMatrix,
    ) -> ImpellerColorFilter;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  mask_filter  The mask filter.\n"]
    pub fn ImpellerMaskFilterRetain(mask_filter: ImpellerMaskFilter);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  mask_filter  The mask filter.\n"]
    pub fn ImpellerMaskFilterRelease(mask_filter: ImpellerMaskFilter);
    #[doc = "@brief      Create a mask filter that blurs contents in the masked shape.\n\n@param[in]  style  The style.\n@param[in]  sigma  The sigma.\n\n@return     The mask filter.\n"]
    pub fn ImpellerMaskFilterCreateBlurNew(style: BlurStyle, sigma: f32) -> ImpellerMaskFilter;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  image_filter  The image filter.\n"]
    pub fn ImpellerImageFilterRetain(image_filter: ImpellerImageFilter);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  image_filter  The image filter.\n"]
    pub fn ImpellerImageFilterRelease(image_filter: ImpellerImageFilter);
    #[doc = "@brief      Creates an image filter that applies a Gaussian blur.\n\nThe Gaussian blur applied may be an approximation for\nperformance.\n\n\n@param[in]  x_sigma    The x sigma.\n@param[in]  y_sigma    The y sigma.\n@param[in]  tile_mode  The tile mode.\n\n@return     The image filter.\n"]
    pub fn ImpellerImageFilterCreateBlurNew(
        x_sigma: f32,
        y_sigma: f32,
        tile_mode: TileMode,
    ) -> ImpellerImageFilter;
    #[doc = "@brief      Creates an image filter that enhances the per-channel pixel\nvalues to the maximum value in a circle around the pixel.\n\n@param[in]  x_radius  The x radius.\n@param[in]  y_radius  The y radius.\n\n@return     The image filter.\n"]
    pub fn ImpellerImageFilterCreateDilateNew(x_radius: f32, y_radius: f32) -> ImpellerImageFilter;
    #[doc = "@brief      Creates an image filter that dampens the per-channel pixel\nvalues to the minimum value in a circle around the pixel.\n\n@param[in]  x_radius  The x radius.\n@param[in]  y_radius  The y radius.\n\n@return     The image filter.\n"]
    pub fn ImpellerImageFilterCreateErodeNew(x_radius: f32, y_radius: f32) -> ImpellerImageFilter;
    #[doc = "@brief      Creates an image filter that applies a transformation matrix to\nthe underlying image.\n\n@param[in]  matrix    The transformation matrix.\n@param[in]  sampling  The image sampling mode.\n\n@return     The image filter.\n"]
    pub fn ImpellerImageFilterCreateMatrixNew(
        matrix: *const ImpellerMatrix,
        sampling: TextureSampling,
    ) -> ImpellerImageFilter;
    #[doc = "@brief      Create an image filter where each pixel is shaded by a fragment\nprogram.\n\n@see        https://docs.flutter.dev/ui/design/graphics/fragment-shaders\n\n@param[in]  context            The context.\n@param[in]  fragment_program   The fragment program.\n@param      samplers           The samplers.\n@param[in]  samplers_count     The samplers count.\n@param[in]  data               The data (copied).\n@param[in]  data_bytes_length  The data bytes length.\n\n@return     The image filter.\n"]
    pub fn ImpellerImageFilterCreateFragmentProgramNew(
        context: ImpellerContext,
        fragment_program: ImpellerFragmentProgram,
        samplers: *mut ImpellerTexture,
        samplers_count: usize,
        data: *const u8,
        data_bytes_length: usize,
    ) -> ImpellerImageFilter;
    #[doc = "@brief      Creates a composed filter that when applied is identical to\nsubsequently applying the inner and then the outer filters.\n\n```cpp\ndestination = outer_filter(inner_filter(source))\n```\n\n@param[in]  outer  The outer image filter.\n@param[in]  inner  The inner image filter.\n\n@return     The combined image filter.\n"]
    pub fn ImpellerImageFilterCreateComposeNew(
        outer: ImpellerImageFilter,
        inner: ImpellerImageFilter,
    ) -> ImpellerImageFilter;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  display_list  The display list.\n"]
    pub fn ImpellerDisplayListRetain(display_list: ImpellerDisplayList);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  display_list  The display list.\n"]
    pub fn ImpellerDisplayListRelease(display_list: ImpellerDisplayList);
    #[doc = "@brief      Create a new display list builder.\n\nAn optional cull rectangle may be specified. Impeller is allowed\nto treat the contents outside this rectangle as being undefined.\nThis may aid performance optimizations.\n\n@param[in]  cull_rect  The cull rectangle or NULL.\n\n@return     The display list builder.\n"]
    pub fn ImpellerDisplayListBuilderNew(
        cull_rect: *const ImpellerRect,
    ) -> ImpellerDisplayListBuilder;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  builder  The display list builder.\n"]
    pub fn ImpellerDisplayListBuilderRetain(builder: ImpellerDisplayListBuilder);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  builder  The display list builder.\n"]
    pub fn ImpellerDisplayListBuilderRelease(builder: ImpellerDisplayListBuilder);
    #[doc = "@brief      Create a new display list using the rendering intent already\nencoded in the builder. The builder is reset after this call.\n\n@param[in]  builder  The builder.\n\n@return     The display list.\n"]
    pub fn ImpellerDisplayListBuilderCreateDisplayListNew(
        builder: ImpellerDisplayListBuilder,
    ) -> ImpellerDisplayList;
    #[doc = "@brief      Stashes the current transformation and clip state onto a save\nstack.\n\n@param[in]  builder  The builder.\n"]
    pub fn ImpellerDisplayListBuilderSave(builder: ImpellerDisplayListBuilder);
    #[doc = "@brief      Stashes the current transformation and clip state onto a save\nstack and creates and creates an offscreen layer onto which\nsubsequent rendering intent will be directed to.\n\nOn the balancing call to restore, the supplied paints filters\nand blend modes will be used to composite the offscreen contents\nback onto the display display list.\n\n@param[in]  builder   The builder.\n@param[in]  bounds    The bounds.\n@param[in]  paint     The paint.\n@param[in]  backdrop  The backdrop.\n"]
    pub fn ImpellerDisplayListBuilderSaveLayer(
        builder: ImpellerDisplayListBuilder,
        bounds: *const ImpellerRect,
        paint: ImpellerPaint,
        backdrop: ImpellerImageFilter,
    );
    #[doc = "@brief      Pops the last entry pushed onto the save stack using a call to\n`ImpellerDisplayListBuilderSave` or\n`ImpellerDisplayListBuilderSaveLayer`.\n\n@param[in]  builder  The builder.\n"]
    pub fn ImpellerDisplayListBuilderRestore(builder: ImpellerDisplayListBuilder);
    #[doc = "@brief      Apply a scale to the transformation matrix currently on top of\nthe save stack.\n\n@param[in]  builder  The builder.\n@param[in]  x_scale  The x scale.\n@param[in]  y_scale  The y scale.\n"]
    pub fn ImpellerDisplayListBuilderScale(
        builder: ImpellerDisplayListBuilder,
        x_scale: f32,
        y_scale: f32,
    );
    #[doc = "@brief      Apply a clockwise rotation to the transformation matrix\ncurrently on top of the save stack.\n\n@param[in]  builder        The builder.\n@param[in]  angle_degrees  The angle in degrees.\n"]
    pub fn ImpellerDisplayListBuilderRotate(
        builder: ImpellerDisplayListBuilder,
        angle_degrees: f32,
    );
    #[doc = "@brief      Apply a translation to the transformation matrix currently on\ntop of the save stack.\n\n@param[in]  builder        The builder.\n@param[in]  x_translation  The x translation.\n@param[in]  y_translation  The y translation.\n"]
    pub fn ImpellerDisplayListBuilderTranslate(
        builder: ImpellerDisplayListBuilder,
        x_translation: f32,
        y_translation: f32,
    );
    #[doc = "@brief      Appends the the provided transformation to the transformation\nalready on the save stack.\n\n@param[in]  builder    The builder.\n@param[in]  transform  The transform to append.\n"]
    pub fn ImpellerDisplayListBuilderTransform(
        builder: ImpellerDisplayListBuilder,
        transform: *const ImpellerMatrix,
    );
    #[doc = "@brief      Clear the transformation on top of the save stack and replace it\nwith a new value.\n\n@param[in]  builder    The builder.\n@param[in]  transform  The new transform.\n"]
    pub fn ImpellerDisplayListBuilderSetTransform(
        builder: ImpellerDisplayListBuilder,
        transform: *const ImpellerMatrix,
    );
    #[doc = "@brief      Get the transformation currently built up on the top of the\ntransformation stack.\n\n@param[in]  builder        The builder.\n@param[out] out_transform  The transform.\n"]
    pub fn ImpellerDisplayListBuilderGetTransform(
        builder: ImpellerDisplayListBuilder,
        out_transform: *mut ImpellerMatrix,
    );
    #[doc = "@brief      Reset the transformation on top of the transformation stack to\nidentity.\n\n@param[in]  builder  The builder.\n"]
    pub fn ImpellerDisplayListBuilderResetTransform(builder: ImpellerDisplayListBuilder);
    #[doc = "@brief      Get the current size of the save stack.\n\n@param[in]  builder  The builder.\n\n@return     The save stack size.\n"]
    pub fn ImpellerDisplayListBuilderGetSaveCount(builder: ImpellerDisplayListBuilder) -> u32;
    #[doc = "@brief      Effectively calls ImpellerDisplayListBuilderRestore till the\nsize of the save stack becomes a specified count.\n\n@param[in]  builder  The builder.\n@param[in]  count    The count.\n"]
    pub fn ImpellerDisplayListBuilderRestoreToCount(
        builder: ImpellerDisplayListBuilder,
        count: u32,
    );
    #[doc = "@brief      Reduces the clip region to the intersection of the current clip\nand the given rectangle taking into account the clip operation.\n\n@param[in]  builder  The builder.\n@param[in]  rect     The rectangle.\n@param[in]  op       The operation.\n"]
    pub fn ImpellerDisplayListBuilderClipRect(
        builder: ImpellerDisplayListBuilder,
        rect: *const ImpellerRect,
        op: ClipOperation,
    );
    #[doc = "@brief      Reduces the clip region to the intersection of the current clip\nand the given oval taking into account the clip operation.\n\n@param[in]  builder      The builder.\n@param[in]  oval_bounds  The oval bounds.\n@param[in]  op           The operation.\n"]
    pub fn ImpellerDisplayListBuilderClipOval(
        builder: ImpellerDisplayListBuilder,
        oval_bounds: *const ImpellerRect,
        op: ClipOperation,
    );
    #[doc = "@brief      Reduces the clip region to the intersection of the current clip\nand the given rounded rectangle taking into account the clip\noperation.\n\n@param[in]  builder  The builder.\n@param[in]  rect     The rectangle.\n@param[in]  radii    The radii.\n@param[in]  op       The operation.\n"]
    pub fn ImpellerDisplayListBuilderClipRoundedRect(
        builder: ImpellerDisplayListBuilder,
        rect: *const ImpellerRect,
        radii: *const ImpellerRoundingRadii,
        op: ClipOperation,
    );
    #[doc = "@brief      Reduces the clip region to the intersection of the current clip\nand the given path taking into account the clip operation.\n\n@param[in]  builder  The builder.\n@param[in]  path     The path.\n@param[in]  op       The operation.\n"]
    pub fn ImpellerDisplayListBuilderClipPath(
        builder: ImpellerDisplayListBuilder,
        path: ImpellerPath,
        op: ClipOperation,
    );
    #[doc = "@brief      Fills the current clip with the specified paint.\n\n@param[in]  builder  The builder.\n@param[in]  paint    The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawPaint(
        builder: ImpellerDisplayListBuilder,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Draws a line segment.\n\n@param[in]  builder  The builder.\n@param[in]  from     The starting point of the line.\n@param[in]  to       The end point of the line.\n@param[in]  paint    The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawLine(
        builder: ImpellerDisplayListBuilder,
        from: *const ImpellerPoint,
        to: *const ImpellerPoint,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Draws a dash line segment.\n\n@param[in]  builder     The builder.\n@param[in]  from        The starting point of the line.\n@param[in]  to          The end point of the line.\n@param[in]  on_length   On length.\n@param[in]  off_length  Off length.\n@param[in]  paint       The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawDashedLine(
        builder: ImpellerDisplayListBuilder,
        from: *const ImpellerPoint,
        to: *const ImpellerPoint,
        on_length: f32,
        off_length: f32,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Draws a rectangle.\n\n@param[in]  builder  The builder.\n@param[in]  rect     The rectangle.\n@param[in]  paint    The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawRect(
        builder: ImpellerDisplayListBuilder,
        rect: *const ImpellerRect,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Draws an oval.\n\n@param[in]  builder      The builder.\n@param[in]  oval_bounds  The oval bounds.\n@param[in]  paint        The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawOval(
        builder: ImpellerDisplayListBuilder,
        oval_bounds: *const ImpellerRect,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Draws a rounded rect.\n\n@param[in]  builder  The builder.\n@param[in]  rect     The rectangle.\n@param[in]  radii    The radii.\n@param[in]  paint    The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawRoundedRect(
        builder: ImpellerDisplayListBuilder,
        rect: *const ImpellerRect,
        radii: *const ImpellerRoundingRadii,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Draws a shape that is the different between the specified\nrectangles (each with configurable corner radii).\n\n@param[in]  builder      The builder.\n@param[in]  outer_rect   The outer rectangle.\n@param[in]  outer_radii  The outer radii.\n@param[in]  inner_rect   The inner rectangle.\n@param[in]  inner_radii  The inner radii.\n@param[in]  paint        The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawRoundedRectDifference(
        builder: ImpellerDisplayListBuilder,
        outer_rect: *const ImpellerRect,
        outer_radii: *const ImpellerRoundingRadii,
        inner_rect: *const ImpellerRect,
        inner_radii: *const ImpellerRoundingRadii,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Draws the specified shape.\n\n@param[in]  builder  The builder.\n@param[in]  path     The path.\n@param[in]  paint    The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawPath(
        builder: ImpellerDisplayListBuilder,
        path: ImpellerPath,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Flattens the contents of another display list into the one\ncurrently being built.\n\n@param[in]  builder       The builder.\n@param[in]  display_list  The display list.\n@param[in]  opacity       The opacity.\n"]
    pub fn ImpellerDisplayListBuilderDrawDisplayList(
        builder: ImpellerDisplayListBuilder,
        display_list: ImpellerDisplayList,
        opacity: f32,
    );
    #[doc = "@brief      Draw a paragraph at the specified point.\n\n@param[in]  builder    The builder.\n@param[in]  paragraph  The paragraph.\n@param[in]  point      The point.\n"]
    pub fn ImpellerDisplayListBuilderDrawParagraph(
        builder: ImpellerDisplayListBuilder,
        paragraph: ImpellerParagraph,
        point: *const ImpellerPoint,
    );
    #[doc = "@brief      Draw a shadow for a Path given a material elevation. If the\noccluding object is not opaque, additional hints (via the\n`occluder_is_transparent` argument) must be provided to render\nthe shadow correctly.\n\n@param[in]  builder    The builder.\n@param[in]  path       The shadow path.\n@param[in]  color      The shadow color.\n@param[in]  elevation  The material elevation.\n@param[in]  occluder_is_transparent\nIf the object casting the shadow is transparent.\n@param[in]  device_pixel_ratio\nThe device pixel ratio.\n"]
    pub fn ImpellerDisplayListBuilderDrawShadow(
        builder: ImpellerDisplayListBuilder,
        path: ImpellerPath,
        color: *const ImpellerColor,
        elevation: f32,
        occluder_is_transparent: bool,
        device_pixel_ratio: f32,
    );
    #[doc = "@brief      Draw a texture at the specified point.\n\n@param[in]  builder   The builder.\n@param[in]  texture   The texture.\n@param[in]  point     The point.\n@param[in]  sampling  The sampling.\n@param[in]  paint     The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawTexture(
        builder: ImpellerDisplayListBuilder,
        texture: ImpellerTexture,
        point: *const ImpellerPoint,
        sampling: TextureSampling,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Draw a portion of texture at the specified location.\n\n@param[in]  builder   The builder.\n@param[in]  texture   The texture.\n@param[in]  src_rect  The source rectangle.\n@param[in]  dst_rect  The destination rectangle.\n@param[in]  sampling  The sampling.\n@param[in]  paint     The paint.\n"]
    pub fn ImpellerDisplayListBuilderDrawTextureRect(
        builder: ImpellerDisplayListBuilder,
        texture: ImpellerTexture,
        src_rect: *const ImpellerRect,
        dst_rect: *const ImpellerRect,
        sampling: TextureSampling,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Create a new typography contents.\n\n@return     The typography context.\n"]
    pub fn ImpellerTypographyContextNew() -> ImpellerTypographyContext;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  context  The typography context.\n"]
    pub fn ImpellerTypographyContextRetain(context: ImpellerTypographyContext);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  context  The typography context.\n"]
    pub fn ImpellerTypographyContextRelease(context: ImpellerTypographyContext);
    #[doc = "@brief      Register a custom font.\n\nThe following font formats are supported:\n* OpenType font collections (.ttc extension)\n* TrueType fonts: (.ttf extension)\n* OpenType fonts: (.otf extension)\n\n@warning    Web Open Font Formats (.woff and .woff2 extensions) are **not**\nsupported.\n\nThe font data is specified as a mapping. It is possible for the\nrelease callback of the mapping to not be called even past the\ndestruction of the typography context. Care must be taken to not\ncollect the mapping till the release callback is invoked by\nImpeller.\n\nThe family alias name can be NULL. In such cases, the font\nfamily specified in paragraph styles must match the family that\nis specified in the font data.\n\nIf the family name alias is not NULL, that family name must be\nused in the paragraph style to reference glyphs from this font\ninstead of the one encoded in the font itself.\n\nMultiple fonts (with glyphs for different styles) can be\nspecified with the same family.\n\n@see        `ImpellerParagraphStyleSetFontFamily`\n\n@param[in]  context                        The context.\n@param[in]  contents                       The contents.\n@param[in]  contents_on_release_user_data  The user data baton to be passed\nto the contents release callback.\n@param[in]  family_name_alias              The family name alias or NULL if\nthe one specified in the font\ndata is to be used.\n\n@return     If the font could be successfully registered.\n"]
    pub fn ImpellerTypographyContextRegisterFont(
        context: ImpellerTypographyContext,
        contents: *const ImpellerMapping,
        contents_on_release_user_data: *mut ::std::os::raw::c_void,
        family_name_alias: *const ::std::os::raw::c_char,
    ) -> bool;
    #[doc = "@brief      Create a new paragraph style.\n\n@return     The paragraph style.\n"]
    pub fn ImpellerParagraphStyleNew() -> ImpellerParagraphStyle;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  paragraph_style  The paragraph style.\n"]
    pub fn ImpellerParagraphStyleRetain(paragraph_style: ImpellerParagraphStyle);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  paragraph_style  The paragraph style.\n"]
    pub fn ImpellerParagraphStyleRelease(paragraph_style: ImpellerParagraphStyle);
    #[doc = "@brief      Set the paint used to render the text glyph contents.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  paint            The paint.\n"]
    pub fn ImpellerParagraphStyleSetForeground(
        paragraph_style: ImpellerParagraphStyle,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Set the paint used to render the background of the text glyphs.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  paint            The paint.\n"]
    pub fn ImpellerParagraphStyleSetBackground(
        paragraph_style: ImpellerParagraphStyle,
        paint: ImpellerPaint,
    );
    #[doc = "@brief      Set the weight of the font to select when rendering glyphs.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  weight           The weight.\n"]
    pub fn ImpellerParagraphStyleSetFontWeight(
        paragraph_style: ImpellerParagraphStyle,
        weight: FontWeight,
    );
    #[doc = "@brief      Set whether the glyphs should be bolded or italicized.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  style            The style.\n"]
    pub fn ImpellerParagraphStyleSetFontStyle(
        paragraph_style: ImpellerParagraphStyle,
        style: FontStyle,
    );
    #[doc = "@brief      Set the font family.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  family_name      The family name.\n"]
    pub fn ImpellerParagraphStyleSetFontFamily(
        paragraph_style: ImpellerParagraphStyle,
        family_name: *const ::std::os::raw::c_char,
    );
    #[doc = "@brief      Set the font size.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  size             The size.\n"]
    pub fn ImpellerParagraphStyleSetFontSize(paragraph_style: ImpellerParagraphStyle, size: f32);
    #[doc = "@brief      The height of the text as a multiple of text size.\n\nWhen height is 0.0, the line height will be determined by the\nfont's metrics directly, which may differ from the font size.\nOtherwise the line height of the text will be a multiple of font\nsize, and be exactly fontSize * height logical pixels tall.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  height           The height.\n"]
    pub fn ImpellerParagraphStyleSetHeight(paragraph_style: ImpellerParagraphStyle, height: f32);
    #[doc = "@brief      Set the alignment of text within the paragraph.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  align            The align.\n"]
    pub fn ImpellerParagraphStyleSetTextAlignment(
        paragraph_style: ImpellerParagraphStyle,
        align: TextAlignment,
    );
    #[doc = "@brief      Set the directionality of the text within the paragraph.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  direction        The direction.\n"]
    pub fn ImpellerParagraphStyleSetTextDirection(
        paragraph_style: ImpellerParagraphStyle,
        direction: TextDirection,
    );
    #[doc = "@brief      Set one of more text decorations on the paragraph. Decorations\ncan be underlines, overlines, strikethroughs, etc.. The style of\ndecorations can be set as well (dashed, dotted, wavy, etc..)\n\n@param[in]  ImpellerParagraphStyle  The paragraph style.\n@param[in]  decoration              The text decoration.\n"]
    pub fn ImpellerParagraphStyleSetTextDecoration(
        paragraph_style: ImpellerParagraphStyle,
        decoration: *const ImpellerTextDecoration,
    );
    #[doc = "@brief      Set the maximum line count within the paragraph.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  max_lines        The maximum lines.\n"]
    pub fn ImpellerParagraphStyleSetMaxLines(
        paragraph_style: ImpellerParagraphStyle,
        max_lines: u32,
    );
    #[doc = "@brief      Set the paragraph locale.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  locale           The locale.\n"]
    pub fn ImpellerParagraphStyleSetLocale(
        paragraph_style: ImpellerParagraphStyle,
        locale: *const ::std::os::raw::c_char,
    );
    #[doc = "@brief      Set the UTF-8 string to use as the ellipsis. Pass `nullptr` to\nclear the setting to default.\n\n@param[in]  paragraph_style  The paragraph style.\n@param[in]  data             The ellipsis string UTF-8 data, or null.\n"]
    pub fn ImpellerParagraphStyleSetEllipsis(
        paragraph_style: ImpellerParagraphStyle,
        ellipsis: *const ::std::os::raw::c_char,
    );
    #[doc = "@brief      Create a new paragraph builder.\n\n@param[in]  context  The context.\n\n@return     The paragraph builder.\n"]
    pub fn ImpellerParagraphBuilderNew(
        context: ImpellerTypographyContext,
    ) -> ImpellerParagraphBuilder;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  paragraph_builder  The paragraph builder.\n"]
    pub fn ImpellerParagraphBuilderRetain(paragraph_builder: ImpellerParagraphBuilder);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  paragraph_builder  The paragraph_builder.\n"]
    pub fn ImpellerParagraphBuilderRelease(paragraph_builder: ImpellerParagraphBuilder);
    #[doc = "@brief      Push a new paragraph style onto the paragraph style stack\nmanaged by the paragraph builder.\n\nNot all paragraph styles can be combined. For instance, it does\nnot make sense to mix text alignment for different text runs\nwithin a paragraph. In such cases, the preference of the the\nfirst paragraph style on the style stack will take hold.\n\nIf text is pushed onto the paragraph builder without a style\npreviously pushed onto the stack, a default paragraph text style\nwill be used. This may not always be desirable because some\nstyle element cannot be overridden. It is recommended that a\ndefault paragraph style always be pushed onto the stack before\nthe addition of any text.\n\n@param[in]  paragraph_builder  The paragraph builder.\n@param[in]  style              The style.\n"]
    pub fn ImpellerParagraphBuilderPushStyle(
        paragraph_builder: ImpellerParagraphBuilder,
        style: ImpellerParagraphStyle,
    );
    #[doc = "@brief      Pop a previously pushed paragraph style from the paragraph style\nstack.\n\n@param[in]  paragraph_builder  The paragraph builder.\n"]
    pub fn ImpellerParagraphBuilderPopStyle(paragraph_builder: ImpellerParagraphBuilder);
    #[doc = "@brief      Add UTF-8 encoded text to the paragraph. The text will be styled\naccording to the paragraph style already on top of the paragraph\nstyle stack.\n\n@param[in]  paragraph_builder  The paragraph builder.\n@param[in]  data               The data.\n@param[in]  length             The length.\n"]
    pub fn ImpellerParagraphBuilderAddText(
        paragraph_builder: ImpellerParagraphBuilder,
        data: *const u8,
        length: u32,
    );
    #[doc = "@brief      Layout and build a new paragraph using the specified width. The\nresulting paragraph is immutable. The paragraph builder must be\ndiscarded and a new one created to build more paragraphs.\n\n@param[in]  paragraph_builder  The paragraph builder.\n@param[in]  width              The paragraph width.\n\n@return     The paragraph if one can be created, NULL otherwise.\n"]
    pub fn ImpellerParagraphBuilderBuildParagraphNew(
        paragraph_builder: ImpellerParagraphBuilder,
        width: f32,
    ) -> ImpellerParagraph;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  paragraph  The paragraph.\n"]
    pub fn ImpellerParagraphRetain(paragraph: ImpellerParagraph);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  paragraph  The paragraph.\n"]
    pub fn ImpellerParagraphRelease(paragraph: ImpellerParagraph);
    #[doc = "@see        `ImpellerParagraphGetMinIntrinsicWidth`\n\n@param[in]  paragraph  The paragraph.\n\n\n@return     The width provided to the paragraph builder during the call to\nlayout. This is the maximum width any line in the laid out\nparagraph can occupy. But, it is not necessarily the actual\nwidth of the paragraph after layout.\n"]
    pub fn ImpellerParagraphGetMaxWidth(paragraph: ImpellerParagraph) -> f32;
    #[doc = "@param[in]  paragraph  The paragraph.\n\n@return     The height of the laid out paragraph. This is **not** a tight\nbounding box and some glyphs may not reach the minimum location\nthey are allowed to reach.\n"]
    pub fn ImpellerParagraphGetHeight(paragraph: ImpellerParagraph) -> f32;
    #[doc = "@param[in]  paragraph  The paragraph.\n\n@return     The length of the longest line in the paragraph. This is the\nhorizontal distance between the left edge of the leftmost glyph\nand the right edge of the rightmost glyph, in the longest line\nin the paragraph.\n"]
    pub fn ImpellerParagraphGetLongestLineWidth(paragraph: ImpellerParagraph) -> f32;
    #[doc = "@see        `ImpellerParagraphGetMaxWidth`\n\n@param[in]  paragraph  The paragraph.\n\n@return     The actual width of the longest line in the paragraph after\nlayout. This is expected to be less than or equal to\n`ImpellerParagraphGetMaxWidth`.\n"]
    pub fn ImpellerParagraphGetMinIntrinsicWidth(paragraph: ImpellerParagraph) -> f32;
    #[doc = "@param[in]  paragraph  The paragraph.\n\n@return     The width of the paragraph without line breaking.\n"]
    pub fn ImpellerParagraphGetMaxIntrinsicWidth(paragraph: ImpellerParagraph) -> f32;
    #[doc = "@param[in]  paragraph  The paragraph.\n\n@return     The distance from the top of the paragraph to the ideographic\nbaseline of the first line when using ideographic fonts\n(Japanese, Korean, etc...).\n"]
    pub fn ImpellerParagraphGetIdeographicBaseline(paragraph: ImpellerParagraph) -> f32;
    #[doc = "@param[in]  paragraph  The paragraph.\n\n@return     The distance from the top of the paragraph to the alphabetic\nbaseline of the first line when using alphabetic fonts (A-Z,\na-z, Greek, etc...).\n"]
    pub fn ImpellerParagraphGetAlphabeticBaseline(paragraph: ImpellerParagraph) -> f32;
    #[doc = "@param[in]  paragraph  The paragraph.\n\n@return     The number of lines visible in the paragraph after line\nbreaking.\n"]
    pub fn ImpellerParagraphGetLineCount(paragraph: ImpellerParagraph) -> u32;
    #[doc = "@brief      Get the range into the UTF-16 code unit buffer that represents\nthe word at the specified caret location in the same buffer.\n\nWord boundaries are defined more precisely in [Unicode Standard\nAnnex #29](http://www.unicode.org/reports/tr29/#Word_Boundaries)\n\n@param[in]  paragraph        The paragraph\n@param[in]  code_unit_index  The code unit index\n@param[out]  code_unit_index The range.\n"]
    pub fn ImpellerParagraphGetWordBoundary(
        paragraph: ImpellerParagraph,
        code_unit_index: usize,
        out_range: *mut ImpellerRange,
    );
    #[doc = "@brief      Get the line metrics of this laid out paragraph. Calculating the\nline metrics is expensive. The first time line metrics are\nrequested, they will be cached along with the paragraph (which\nis immutable).\n\n@param[in]  paragraph  The paragraph.\n\n@return     The line metrics.\n"]
    pub fn ImpellerParagraphGetLineMetrics(paragraph: ImpellerParagraph) -> ImpellerLineMetrics;
    #[doc = "@brief      Create a new instance of glyph info that can be queried for\ninformation about the glyph at the given UTF-16 code unit index.\nThe instance must be freed using `ImpellerGlyphInfoRelease`.\n\n@param[in]  paragraph        The paragraph.\n@param[in]  code_unit_index  The UTF-16 code unit index.\n\n@return     The glyph information.\n"]
    pub fn ImpellerParagraphCreateGlyphInfoAtCodeUnitIndexNew(
        paragraph: ImpellerParagraph,
        code_unit_index: usize,
    ) -> ImpellerGlyphInfo;
    #[doc = "@brief      Create a new instance of glyph info that can be queried for\ninformation about the glyph closest to the specified coordinates\nrelative to the origin of the paragraph. The instance must be\nfreed using `ImpellerGlyphInfoRelease`.\n\n@param[in]  paragraph  The paragraph.\n@param[in]  x          The x coordinate relative to paragraph origin.\n@param[in]  y          The x coordinate relative to paragraph origin.\n\n@return     The glyph information.\n"]
    pub fn ImpellerParagraphCreateGlyphInfoAtParagraphCoordinatesNew(
        paragraph: ImpellerParagraph,
        x: f64,
        y: f64,
    ) -> ImpellerGlyphInfo;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  line_metrics  The line metrics.\n"]
    pub fn ImpellerLineMetricsRetain(line_metrics: ImpellerLineMetrics);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  line_metrics  The line metrics.\n"]
    pub fn ImpellerLineMetricsRelease(line_metrics: ImpellerLineMetrics);
    #[doc = "@brief      The rise from the baseline as calculated from the font and style\nfor this line ignoring the height from the text style.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The unscaled ascent.\n"]
    pub fn ImpellerLineMetricsGetUnscaledAscent(metrics: ImpellerLineMetrics, line: usize) -> f64;
    #[doc = "@brief      The rise from the baseline as calculated from the font and style\nfor this line.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The ascent.\n"]
    pub fn ImpellerLineMetricsGetAscent(metrics: ImpellerLineMetrics, line: usize) -> f64;
    #[doc = "@brief      The drop from the baseline as calculated from the font and style\nfor this line.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The descent.\n"]
    pub fn ImpellerLineMetricsGetDescent(metrics: ImpellerLineMetrics, line: usize) -> f64;
    #[doc = "@brief      The y coordinate of the baseline for this line from the top of\nthe paragraph.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The baseline.\n"]
    pub fn ImpellerLineMetricsGetBaseline(metrics: ImpellerLineMetrics, line: usize) -> f64;
    #[doc = "@brief      Used to determine if this line ends with an explicit line break\n(e.g. '\\n') or is the end of the paragraph.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     True if the line is a hard break.\n"]
    pub fn ImpellerLineMetricsIsHardbreak(metrics: ImpellerLineMetrics, line: usize) -> bool;
    #[doc = "@brief      Width of the line from the left edge of the leftmost glyph to\nthe right edge of the rightmost glyph.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The width.\n"]
    pub fn ImpellerLineMetricsGetWidth(metrics: ImpellerLineMetrics, line: usize) -> f64;
    #[doc = "@brief      Total height of the line from the top edge to the bottom edge.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The height.\n"]
    pub fn ImpellerLineMetricsGetHeight(metrics: ImpellerLineMetrics, line: usize) -> f64;
    #[doc = "@brief      The x coordinate of left edge of the line.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The left edge coordinate.\n"]
    pub fn ImpellerLineMetricsGetLeft(metrics: ImpellerLineMetrics, line: usize) -> f64;
    #[doc = "@brief      Fetch the start index in the buffer of UTF-16 code units used to\nrepresent the paragraph line.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The UTF-16 code units start index.\n"]
    pub fn ImpellerLineMetricsGetCodeUnitStartIndex(
        metrics: ImpellerLineMetrics,
        line: usize,
    ) -> usize;
    #[doc = "@brief      Fetch the end index in the buffer of UTF-16 code units used to\nrepresent the paragraph line.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The UTF-16 code units end index.\n"]
    pub fn ImpellerLineMetricsGetCodeUnitEndIndex(
        metrics: ImpellerLineMetrics,
        line: usize,
    ) -> usize;
    #[doc = "@brief      Fetch the end index (excluding whitespace) in the buffer of\nUTF-16 code units used to represent the paragraph line.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The UTF-16 code units end index excluding whitespace.\n"]
    pub fn ImpellerLineMetricsGetCodeUnitEndIndexExcludingWhitespace(
        metrics: ImpellerLineMetrics,
        line: usize,
    ) -> usize;
    #[doc = "@brief      Fetch the end index (including newlines) in the buffer of UTF-16\ncode units used to represent the paragraph line.\n\n@param[in]  metrics  The metrics.\n@param[in]  line     The line index (zero based).\n\n@return     The UTF-16 code units end index including newlines.\n"]
    pub fn ImpellerLineMetricsGetCodeUnitEndIndexIncludingNewline(
        metrics: ImpellerLineMetrics,
        line: usize,
    ) -> usize;
    #[doc = "@brief      Retain a strong reference to the object. The object can be NULL\nin which case this method is a no-op.\n\n@param[in]  glyph_info  The glyph information.\n"]
    pub fn ImpellerGlyphInfoRetain(glyph_info: ImpellerGlyphInfo);
    #[doc = "@brief      Release a previously retained reference to the object. The\nobject can be NULL in which case this method is a no-op.\n\n@param[in]  glyph_info  The glyph information.\n"]
    pub fn ImpellerGlyphInfoRelease(glyph_info: ImpellerGlyphInfo);
    #[doc = "@brief      Fetch the start index in the buffer of UTF-16 code units used to\nrepresent the grapheme cluster for a glyph.\n\n@param[in]  glyph_info  The glyph information.\n\n@return     The UTF-16 code units start index.\n"]
    pub fn ImpellerGlyphInfoGetGraphemeClusterCodeUnitRangeBegin(
        glyph_info: ImpellerGlyphInfo,
    ) -> usize;
    #[doc = "@brief      Fetch the end index in the buffer of UTF-16 code units used to\nrepresent the grapheme cluster for a glyph.\n\n@param[in]  glyph_info  The glyph information.\n\n@return     The UTF-16 code units end index.\n"]
    pub fn ImpellerGlyphInfoGetGraphemeClusterCodeUnitRangeEnd(
        glyph_info: ImpellerGlyphInfo,
    ) -> usize;
    #[doc = "@brief      Fetch the bounds of the grapheme cluster for the glyph in the\ncoordinate space of the paragraph.\n\n@param[in]  glyph_info  The glyph information.\n@param[out] out_bounds  The grapheme cluster bounds.\n"]
    pub fn ImpellerGlyphInfoGetGraphemeClusterBounds(
        glyph_info: ImpellerGlyphInfo,
        out_bounds: *mut ImpellerRect,
    );
    #[doc = "@param[in]  glyph_info  The glyph information.\n\n@return     True if the glyph represents an ellipsis. False otherwise.\n"]
    pub fn ImpellerGlyphInfoIsEllipsis(glyph_info: ImpellerGlyphInfo) -> bool;
    #[doc = "@param[in]  glyph_info  The glyph information.\n\n@return     The direction of the run that contains the glyph.\n"]
    pub fn ImpellerGlyphInfoGetTextDirection(glyph_info: ImpellerGlyphInfo) -> TextDirection;
}
