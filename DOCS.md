This directory contains:
* `impeller.h` - impeller's C API header symlinked for convenience
* `generate_impeller_api_json.py` - to generate a json with impeller's C API (impeller.h)
* `impeller_api.json` - the json file generated by above script for convenience
* `impellers` - rust library that does two things
  * generates raw FFI bindings for impeller's C API using codegen feature (with bindgen)
  * wraps the FFI bindings with safe rust types and functions. and uses build script to download/link the prebuilt impeller library artefacts

### Rust Bindings Generation
We will assume that you are in the root of the repo.
Just run:
> `cargo run -p impellers_codegen

If you first set the `env` variable `RUST_LOG=debug`, the generator will log a bunch of extra stuff to stdout which might be helpful if you are debugging it.

Generated bindings will be placed in `src/sys.rs`.
The `codegen.rs` file contains the code to generate the bindings. We do some convenient "post-processing" to make the bindings easier to re-export by default.
eg: We strip the Impeller prefix from enum names and the enum name prefixes from enum variants to match rust naming conventions.

### Safe Rust API
The `src/lib.rs` contains the safe rust API. It is mostly a thin wrapper around the raw bindings.
The documentation is rough (mostly copy-pasted from `impeller.h`).


### API.json
It covers *most* of the API, except "macros" (including version macros)
Here's a few tips:
* All identifiers start with `Impeller`
* Almost ALL functions are "methods" which take a handle (opaque struct pointer) as the first argument. These function names start with the name of the handle. For example, if the handle name is ImpellerContext, the name of the function to delete it would be ImpellerContextRelease.
* While we do have structs like rect/matrix, their functionality is not included her. So, you must implement the matrix multiplication or translating rect etc.. yourself.
* The json file doesn't specify which structs are thread-safe, you must manually read the docs for that.
* some fields may be skipped if they have default values. eg: you may assume that nonnull (boolean) default is false if not explicitly specified.

The structure is pretty simple. The root object contains 4 objects:
1. `enums`: The keys in this object are "enum" names and the values are list of "variant" names. Use this to generate enums.
2. `handles`: The keys are names of opaque structs. The values are simply the docstrings of these handles.
3. `functions`: the keys in this object are function names. The values are objects with these keys:
    1. `doc`: this is the docstring of the function
    2. `return_ty`: this is an object
        1. `nodiscard`: whether the return type should be discarded (default is false)
        2. `ty`: the return type of the fn. we more or less just copy/paste the c type like "const uint32_t*", so it is upto you to interpret it.
        3. `nonnull`: If the return type is a pointer/handle, whether it should be non-null. default is false.
    3. `args`: this is an array of arg objects (and also used as field object for pod structs - see below). each arg object has the following properties
        1. `name`: name of argument
        2. `ty`: type of argument, just like return type, we copy-paste the type from source. The first arg is almost always a handle.
        3. `nonnull`: If pointer or handle type, whether it should be non-null (default false)
        4. `array_size`: If argument is an array (pointer?), the size of the required array. (default 0, as arrays are very rare)
4. `pod_structs`: This is an object where keys are names of the PlainOldData C structs (non-opaque). The values are objects describing the struct.
    1. `doc`: docstring of type
    2. `fields`: an array of fields of this struct, and each field is exactly the same as the arg of a function. look above for the description of the arg object
5. `types`: Finally, this holds the types used in the Impeller API. eg: 'bool' or 'const uint8_t*'. It is important to note that, this list does not contain handles, enums or pod structs (or pointers to structs). They are implicitly assumed to be used somewhere.
